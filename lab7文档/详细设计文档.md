# 软件详细设计描述文档

[toc]



## 文档修改历史

| 修改人员 | 日期               | 修改原因                                 | 版本号 |
| :------: | ------------------ | ---------------------------------------- | ------ |
|   郑杰   | 2022.6.28   10:29  | 增加1/2/3                                | 1.0    |
|   郑杰   | 2022.6.30    18:26 | 增加目录                                 | 1.1    |
|  徐瀚林  | 2022.7.6    15:00  | controller及service框架                  | 1.2    |
|   郑杰   | 2022.7.7    20:49  | 增加基础功能所有controller及service描述  | 1.3    |
|  秦予惟  | 2022.7.8    22:04  | 画模块设计图                             | 1.4    |
|   郑杰   | 2022.7.9    14:40  | 增加bonus功能所有controller及service描述 | 1.5    |

## 1.引言

### 1.1编制目的

本报告详细完成对ERP进销存管理系统的详细设计，达到指导后续软件构造的目的，同时实现和测试人员及用户的沟通。

本报告面向开发人员、测试人员及最终用户而编写，是了解系统的导航。

### 1.2词汇表

| 词汇名称 | 词汇含义                                                     | 备注 |
| -------- | ------------------------------------------------------------ | ---- |
| ERP      | Enterprise Resource Planning的简称，是一个系统化的企业管理系统 |      |

### 1.3参考资料

[1] 骆斌,丁二玉,刘钦.软件工程与计算.卷二, 软件开发的技术基础[M].北京:机械工业出版社,2013.

## 2.产品概述

将被开发的产品是一款名为ERP的进销存管理系统。

该进销存管理系统是为企业用户，从总经理至普通员工提供的系统化管理系统。其目标在于协助企业员工线上进行办公操作，避免了线下无意义的劳动。帮助中小企业提高信息化程度，提高办公效率和组织程度，从而使得生产效率得以提升。

## 3.体系结构设计概述

从逻辑视图来看，本系统选择了分层体系结构风格，将系统分为展示层、业务逻辑层与数据层；从组合视图来看，本系统包含了一系列开发（物理）包，并在其中有一定的依赖关系；从模块视图来看，主要包含了客户端与服务端，并通过一系列接口来实现各层之间的调用；从信息视角来看，系统拥有一系列PO类来实现数据持久化的目的，并同时辅以数据库表来进行操作。

详见ERP进销存管理系统系统体系结构设计文档中的具体描述。

## 4.结构视角

### 4.1业务逻辑层的分解

业务逻辑层的开发包图参见软件体系结构文档。

#### 4.1.1 账户管理模块

##### 4.1.1.1模块概述

账户管理模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

账户管理模块的职责及接口参见软件系统结构描述文档中的表。

##### 4.1.1.2整体结构

根据整体结构的设计，我们将系统分为展示层，业务逻辑层，数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加AccountService接口。业务逻辑层和数据层之间添加AccountDao接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了AccountController，这样Controller会把业务逻辑处理委托给ServiceImpl对象。PO是作为帖子和评论的持久化对象被添加到设计模型中去的。Service和Dao的接口都是根据依赖倒置原则，避免循环依赖而产生的接口。

账户管理模块的设计图如下图所示。

![财务人员 账户管理.PNG](https://s2.loli.net/2022/07/08/XrqahZmNiy8RvJM.jpg)

账户管理模块各个类的职责如下表所示。

| 模块              | 职责                                                         |
| ----------------- | ------------------------------------------------------------ |
| AccountController | 负责处理用户发来的账户管理相关的请求并调用AccountService中对应的业务逻辑 |
| AccountDao        | 账户管理数据库的接口。提供账户管理的集体载入，增，删，改，查等服务。 |
| AccountService    | 负责实现账户管理相关的业务逻辑                               |

##### 4.1.1.3 模块内部类的接口规范

##### AccountService相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>AccountService.addAccount</td>
		<td>语法</td>
		<td>void addAccount(AccountVO accountVO);</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启账户管理-新增流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>数据库更新完毕，更新流程结束，向用户展示创建成功或失败的信息</td>
	</tr>
    	<tr>
		<td>AccountService.updateAccount</td>
		<td>语法</td>
		<td>void updateAccount(AccountVO accountVO);</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启账户管理-编辑流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>数据库更新完毕，更新流程结束，向用户展示更新成功或失败的信息</td>
	</tr>
    	<tr>
		<td>AccountService.deleteAccount</td>
		<td>语法</td>
		<td>void deleteAccount(String name);</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启账户管理-删除流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>数据库更新完毕，更新流程结束，向用户展示删除成功或失败的信息</td>
	</tr>
    <tr>
		<td>AccountService.queryAll</td>
		<td>语法</td>
		<td>List<AccountVO> queryAll();</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启账户管理-查询流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统列出账户信息</td>
	</tr>
</table>

###### 需要的服务（需接口）

| 服务名                                        | 服务                       |
| --------------------------------------------- | -------------------------- |
| AccountDao.updateAccount(AccountPO accountPO) | 在数据库中更新账户信息     |
| AccountDao.addAccount(AccountPO accountPO)    | 在数据库中插入新增账户信息 |
| AccountDao.deleteAccount(String name)         | 在数据库中删除所选账户信息 |
| AccountDao.queryAll()                         | 查询数据库中所有账户信息   |

##### AccountController相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>AccountController.addCustomer</td>
		<td>语法</td>
		<td>Response addCustomer(@RequestBody AccountVO accountVO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个AccountService对象，用户已登录，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统开启新增账户流程</td>
	</tr>
    <tr>
		<td>AccountController.deleteCustomer</td>
		<td>语法</td>
		<td>Response deleteCustomer(@RequestParam String name)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个AccountService对象，用户已登录，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统删除对应账户信息</td>
	</tr>
    <tr>
		<td>AccountController.updateCustomer</td>
		<td>语法</td>
		<td>Response updateCustomer(@RequestBody AccountVO accountVO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个AccountService对象，用户已登录，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统开启编辑账户信息流程</td>
	</tr>
        <tr>
		<td>AccoutController.queryAll</td>
		<td>语法</td>
		<td>Response queryAll()</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个AccountService对象，用户已登录，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统获得所有账户信息并展示</td>
	</tr>
</table>

###### 需要的服务（需接口）

| 服务名                                            | 服务         |
| ------------------------------------------------- | ------------ |
| AccountService.addAccount(AccountVO  accountVO)   | 新建账户     |
| AccountService.deleteAccount(String name)         | 删除账户     |
| AccountService.updateAccount(AccountVO accountVO) | 编辑账户信息 |
| AccountService.queryAll()                         | 查询账户     |

##### 4.1.1.4 动态模型

![账户管理顺序图 _2_.png](https://s2.loli.net/2022/07/08/hUd1nj2FSeIycX5.png)



##### 4.1.1.5业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同领域对象。

#### 4.1.2 查询经营历程表模块

##### 4.1.2.1模块概述

 查询经营历程表模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

 查询经营历程表模块的职责及接口参见软件系统结构描述文档中的表。

##### 4.1.2.2整体结构

根据整体结构的设计，我们将系统分为展示层，业务逻辑层，数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加BusinessHistoryService接口。业务逻辑层和数据层之间添加BusinessHistoryDao接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了BusinessHistoryController，这样Controller会把业务逻辑处理委托给ServiceImpl对象。PO是作为帖子和评论的持久化对象被添加到设计模型中去的。Service和Dao的接口都是根据依赖倒置原则，避免循环依赖而产生的接口。

查询经营历程表模块的设计图如下图所示。

![财务人员：查看经营历程表.png](https://s2.loli.net/2022/07/08/dGZlLviTWDqw6t3.png)

查询经营历程表模块各个类的职责如下表所示。

| 模块                      | 职责                                                         |
| ------------------------- | ------------------------------------------------------------ |
| BusinessHistoryController | 负责处理用户发来的查询经营历程表相关的请求并调用BusinessHistoryService中对应的业务逻辑 |
| BusinessHistoryService    | 负责实现查询经营历程表相关的业务逻辑                         |
| BusinessHistoryDao        | 查询经营历程表的接口。提供经营历程表的查询、选择类型服务     |

##### 4.1.1.3 模块内部类的接口规范

##### BusinessHistoryController相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>BusinessHistoryController.getSaleDetail</td>
		<td>语法</td>
		<td>Response getSaleDetail(@RequestParam String type,
                                  @RequestParam String beginTimeStr,
                                  @RequestParam String endTimeStr,
                                  @RequestParam String customer,
                                  @RequestParam String operator)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个BusinessHistoryService对象，用户已登录，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统查找对应时间段的对应类型表单并返回给用户</td>
	</tr>
</table>



###### 需要的服务（需接口）

| 服务名                                                       | 服务               |
| ------------------------------------------------------------ | ------------------ |
| BusinessHistoryService.selectSaleSheet(String beginTimeStr, String endTimeStr, String customer, String operator) | 选择销售单类型     |
| BusinessHistoryService.selectSaleReturnsSheet(String beginTimeStr, String endTimeStr, String customer, String operator) | 选择销售退货单类型 |
| BusinessHistoryService.selectPurchaseSheet(String beginTimeStr, String endTimeStr, String customer, String operator) | 选择进货单类型     |
| BusinessHistoryService.selectPurchaseReturnsSheet(String beginTimeStr, String endTimeStr, String customer, String operator) | 选择进货退货单类型 |
| BusinessHistoryService.selectReceiptSheet(String beginTimeStr, String endTimeStr, String customer, String operator) | 选择收款单类型     |
| BusinessHistoryService.selectPaySheet(String beginTimeStr, String endTimeStr, String customer, String operator) | 选择付款单类型     |

##### BusinessHistoryService相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>BusinessHistoryService.selectSaleSheet</td>
		<td>语法</td>
		<td>List<SaleSheetVO> selectSaleSheet(String beginTimeStr, String endTimeStr, String customer, String operator)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启选择查询销售单流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统展示给用户对应时间段的销售单情况</td>
	</tr>
    	<tr>
		<td>BusinessHistoryService.selectSaleReturnsSheet</td>
		<td>语法</td>
		<td>List<SaleReturnsSheetVO> selectSaleReturnsSheet(String beginTimeStr, String endTimeStr, String customer, String operator)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启选择查询销售退货单流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统展示给用户对应时间段的销售退货单情况</td>
	</tr>
        	<tr>
		<td>BusinessHistoryService.selectPurchaseSheet</td>
		<td>语法</td>
		<td>List<PurchaseSheetVO> selectPurchaseSheet(String beginTimeStr, String endTimeStr, String customer, String operator)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启选择查询进货单流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统展示给用户对应时间段的进货单情况</td>
	</tr>
        	<tr>
		<td>BusinessHistoryService.selectPurchaseReturnsSheet</td>
		<td>语法</td>
		<td>List<PurchaseReturnsSheetVO> selectPurchaseReturnsSheet(String beginTimeStr, String endTimeStr, String customer, String operator)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启选择查询进货退货单流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统展示给用户对应时间段的进货退货单情况</td>
	</tr>
        	<tr>
		<td>BusinessHistoryService.selectReceiptSheet</td>
		<td>语法</td>
		<td>List<ReceiptSheetVO> selectReceiptSheet(String beginTimeStr, String endTimeStr, String customer, String operator)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启选择查询收款单流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统展示给用户对应时间段的收款单情况</td>
	</tr>
            	<tr>
		<td>BusinessHistoryService.selectPaySheet</td>
		<td>语法</td>
		<td>List<PaySheetVO> selectPaySheet(String beginTimeStr, String endTimeStr, String customer, String operator)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启选择查询付款单流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统展示给用户对应时间段的付款单情况</td>
	</tr>

</table>

###### 需要的服务（需接口）

| 服务名                                                       | 服务                                         |
| ------------------------------------------------------------ | -------------------------------------------- |
| BusinessHistoryDao.selectSaleSheet(String beginTimeStr, String endTimeStr, String customer, String operator) | 在数据库中获取对应时间段的所有销售表信息     |
| BusinessHistoryDao.selectSaleReturnsSheet(String beginTimeStr, String endTimeStr, String customer, String operator) | 在数据库中获取对应时间段的所有销售退货表信息 |
| BusinessHistoryDao.selectPurchaseSheet(String beginTimeStr, String endTimeStr, String customer, String operator) | 在数据库中获取对应时间段的所有进货表信息     |
| BusinessHistoryDao.selectPurchaseReturnsSheet(String beginTimeStr, String endTimeStr, String customer, String operator) | 在数据库中获取对应时间段的所有进货退货表信息 |
| BusinessHistoryDao.selectReceiptSheet(String beginTimeStr, String endTimeStr, String customer, String operator) | 在数据库中获取对应时间段的所有收款表信息     |
| BusinessHistoryDao.selectPaySheet(String beginTimeStr, String endTimeStr, String customer, String operator) | 在数据库中获取对应时间段的所有付款表信息     |

##### 4.1.2.4动态模型

![查看经营历程表顺序图 _1_.png](https://s2.loli.net/2022/07/09/KfMJkIunDtqs7NZ.png)



##### 4.1.2.5业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同领域对象。

#### 4.1.3 查看销售明细表模块

##### 4.1.3.1模块概述

查看销售明细表模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

查看销售明细表模块的职责及接口参见软件系统结构描述文档表。

##### 4.1.3.2整体结构

根据整体结构的设计，我们将系统分为展示层，业务逻辑层，数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加SaleDetailService接口。业务逻辑层和数据层之间添加SaleDetailSheetDao接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了SaleDetailController，这样Controller会把业务逻辑处理委托给ServiceImpl对象。PO是作为持久化对象被添加到设计模型中去的，作为数据层和业务逻辑层之间传递的数据对象，VO对象是业务逻辑层和控制层之间传递的数据对象。Service和Dao的接口都是根据依赖倒置原则，避免循环依赖而产生的接口。

查看销售明细表模块的设计图如下图所示。

![财务人员：查看销售明细表.png](https://s2.loli.net/2022/07/08/RovFYnLNzTapfg7.png)

查看销售明细表模块各个类的职责如下表所示。

| 模块                 | 职责                                                         |
| -------------------- | ------------------------------------------------------------ |
| SaleDetailController | 负责处理用户发来的查看销售明细表相关的请求并调用SaleDetailService中对应的业务逻辑 |
| SaleDetailService    | 负责实现查看销售明细表相关的业务逻辑                         |
| SaleDetailSheetDao   | 查看销售明细表的接口。提供销售明细表的查询、选择类型的服务。 |

##### 4.1.3.3 模块内部类的接口规范

##### SaleDetailController相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>SaleDetailController.getSaleDetail</td>
		<td>语法</td>
		<td>SaleDetailController(SaleDetailService saleDetailService)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个SaleDetailService对象，用户已登录且为财务人员用户，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统查找对应时间段的对应类型表单并返回给用户</td>
	</tr>
    <tr>
		<td>SaleDetailController.WriteExcel</td>
		<td>语法</td>
		<td>void WriteExcel(HttpServletResponse response)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个SaleDetailService对象，用户已登录且为财务人员用户，销售明细表已生成</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统把表单以excel形式导出到本地并提示用户导出成功</td>
	</tr>
</table>


###### 需要的服务（需接口）

| 服务名                                                       | 服务                       |
| ------------------------------------------------------------ | -------------------------- |
| SaleDetailService.getSaleDetail(String beginTimeStr, String endTimeStr, String proName, String customer, String operator) | 获取一个时间段内的销售明细 |
| SaleDetailService.WriteExcel(HttpServletResponse response)   | 导出销售明细表至本地       |

##### SaleDetailService相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>SaleDetailService.getSaleDetai</td>
		<td>语法</td>
		<td>List<SaleDetailPOJO> getSaleDetail(String beginTimeStr, String endTimeStr, String proName, String customer, String operator)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>用户选择查看销售明细表，系统开启查看销售明细表流程，用户已选择筛选时间段</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统向用户展示对应时间段的销售明细表</td>
	</tr>
    	<tr>
		<td>SaleDetailService.WriteExcel</td>
		<td>语法</td>
		<td>void WriteExcel(HttpServletResponse response)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>销售明细表已生成</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统把表单以excel形式导出到本地并提示用户导出成功</td>
	</tr>
</table>

###### 需要的服务（需接口）

| 服务名                                                       | 服务                               |
| ------------------------------------------------------------ | ---------------------------------- |
| SaleDetailSheetDao.GetSaleDetail(String beginTimeStr, String endTimeStr, String proName, String customer, String operator) | 在数据库中获取对应时间段的销售明细 |

##### 4.1.3.4 动态模型

![查看销售明细表顺序图.png](https://s2.loli.net/2022/07/07/6bjBXZfGvImSMyP.png)

#### 4.1.4 查看经营情况表模块

##### 4.1.3.1模块概述

查看经营情况表模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

查看经营情况表模块的职责及接口参见软件系统结构描述文档表。

##### 4.1.3.2整体结构

根据整体结构的设计，我们将系统分为展示层，业务逻辑层，数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加SaleStatusService接口。业务逻辑层和数据层之间添加saleStatusDao接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了SaleStatusController，这样Controller会把业务逻辑处理委托给ServiceImpl对象。PO是作为持久化对象被添加到设计模型中去的，作为数据层和业务逻辑层之间传递的数据对象，VO对象是业务逻辑层和控制层之间传递的数据对象。Service和Dao的接口都是根据依赖倒置原则，避免循环依赖而产生的接口。

查看经营情况表模块的设计图如下图所示。

![财务人员：查看经营情况表.png](https://s2.loli.net/2022/07/09/epWwfIhHD3KRX45.png)

查看经营情况表模块各个类的职责如下表所示。

| 模块                 | 职责                                                         |
| -------------------- | ------------------------------------------------------------ |
| SaleStatusController | 负责处理用户发来的查看经营情况表相关的请求并调用SaleStatusService中对应的业务逻辑 |
| SaleStatusService    | 负责实现查看经营情况表相关的业务逻辑                         |
| saleStatusDao        | 查看经营情况表的接口。提供经营情况表的查询、选择类型的服务。 |

##### 4.1.3.3 模块内部类的接口规范

##### SaleStatusController相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>SaleStatusController.makeSheet</td>
		<td>语法</td>
		<td>SaleStatusController.makeSheet(String beginTimeStr, String endTimeStr)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个SaleStatusService对象，用户已登录且为财务人员用户，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统开启查找经营情况表流程</td>
	</tr>
    <tr>
		<td>SaleStatusController.redFlush</td>
		<td>语法</td>
		<td>SaleStatusController.redFlush(SaleStatusVO saleStatusVO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个SaleStatusService对象，用户已登录且为财务人员用户，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统开启红冲流程</td>
	</tr>
    	<tr>
		<td>SaleStatusController.queryAll</td>
		<td>语法</td>
		<td>SaleStatusController.queryAll()</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个SaleStatusService对象，用户已登录且为财务人员用户，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统查找所有表单并返回给用户</td>
	</tr>
</table>




###### 需要的服务（需接口）

| 服务名                                                       | 服务                     |
| ------------------------------------------------------------ | ------------------------ |
| SaleStatusService.makeSheet(String beginTimeStr, String endTimeStr) | 查找对应时间段经营情况表 |
| SaleStatusService.redFlush(SaleStatusVO saleStatusVO)        | 红冲                     |
| SaleStatusService.queryAll()                                 | 查找所有经营情况表       |

##### SaleStatusService相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>SaleDetailService.getSaleDetai</td>
		<td>语法</td>
		<td>makeSheet(String beginTimeStr, String endTimeStr)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>用户选择查看经营情况表，系统开启查看经营情况表流程，用户已选择筛选时间段</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统向用户展示对应时间段的销售明细表</td>
	</tr>
    	<tr>
		<td>SaleStatusService.redFlush(SaleStatusVO saleStatusVO)</td>
		<td>语法</td>
		<td>redFlush(SaleStatusVO saleStatusVO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>经营情况表已生成</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统进行红冲操作，更新数据库</td>
	</tr>
    	<tr>
		<td>SaleStatusService.queryAll()</td>
		<td>语法</td>
		<td>List<SaleStatusVO> queryAll()</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>用户选择查看经营情况表，系统开启查看经营情况表流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统向用户展示经营情况表</td>
	</tr>
</table>



###### 需要的服务（需接口）

| 服务名                                                       | 服务                                         |
| ------------------------------------------------------------ | -------------------------------------------- |
| saleStatusDao.getSaleSheet(Date beginTime,Date endTime)      | 在数据库中获取对应时间段的销售经营情况表     |
| saleStatusDao.getPurchaseReturnsSheet(Date beginTime, Date endTime) | 在数据库中获取对应时间段的销售退货经营情况表 |
| saleStatusDao.getPurchaseSheet(Date beginTime,Date endTime)  | 在数据库中获取对应时间段的进货经营情况表     |
| saleStatusDao.getSaleReturnsSheet(Date beginTime, Date endTime) | 在数据库中获取对应时间段的进货退货经营情况表 |
| saleStatusDao.getSalarySheet(Date beginTime, Date endTime)   | 在数据库中获取对应时间段的工资经营情况表     |
| saleStatusDao.save(SaleStatusPO saleStatusPO)                | 在数据库中存放经营情况表                     |
| saleStatusDao.queryAll()                                     | 在数据库中查询经营情况表                     |

##### 4.1.3.4 动态模型

![查看经营情况表顺序图.png](https://s2.loli.net/2022/07/09/FoXhAjug4H1LmCG.png)

#### 4.1.5 制定单据模块

##### 4.1.5.1模块概述

制定单据模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

制定单据模块的职责及接口参见软件系统结构描述文档中的表。

##### 4.1.5.2整体结构

根据整体结构的设计，我们将系统分为展示层，业务逻辑层，数据层。每一层之间为了增加灵活性，我们会添加适当大小的接口。比如展示层和业务逻辑层之间，我们添加了PaySheetService，ReceiptSheetService和SalaryService接口。业务逻辑层和数据层之间添加了PaySheetDao，ReceiptSheetDao,SalaryDao等接口。为了隔离业务逻辑职责和逻辑控制职责，我们还进一步增加了PayController，ReceiptController，SalaryController这样Controller会把业务逻辑处理委托给ServiceImpl对象。PO是作为考试、题目和作答的持久化对象被添加到设计模型中去的。Service和Dao的接口都是根据依赖倒置原则，避免循环依赖而产生的接口。

制定单据模块的设计图如下图所示：

![财务人员：制定付款单.png](https://s2.loli.net/2022/07/08/Hq7kxsZMb5EIJKO.png)

![财务人员_制定收款单.png](https://s2.loli.net/2022/07/08/C3J1KkOBvPY6mQH.png)

![财务人员：制定工资单.png](https://s2.loli.net/2022/07/08/w2E9Usu6pCdQXIb.png)

![总经理制定年终奖.png](https://s2.loli.net/2022/07/09/WnMxcAD29Y7OqKj.png)

制定单据模块各个类的职责如下表所示。

| 模块                   | 职责                                                         |
| ---------------------- | ------------------------------------------------------------ |
| PayController          | 负责处理用户发来的制定付款单相关的请求并调用PaySheetService中对应的业务逻辑 |
| ReceiptController      | 负责处理用户发来的制定收款单相关的请求并调用ReceiptSheetService中对应的业务逻辑 |
| SalaryController       | 负责处理用户发来的制定工资单相关的请求并调用SalaryService中对应的业务逻辑 |
| YearEndBonusController | 负责处理总经理制定年终奖相关的请求并调用YearEndBonusService中对应的业务逻辑 |
| PaySheetService        | 负责实现制定付款单相关的业务逻辑                             |
| ReceiptSheetService    | 负责实现制定收款单相关的业务逻辑                             |
| SalaryService          | 负责实现制定工资单相关的业务逻辑                             |
| YearEndBonusService    | 负责实现制定年终奖相关的业务逻辑                             |
| PaySheetDao            | 制定付款单的接口。提供制定付款单的增删改查服务。             |
| ReceiptSheetDao        | 制定收款单的接口。提供制定收款单的增删改查服务。             |
| SalaryDao              | 制定工资单的接口。提供制定工资单的增删改查服务。             |

##### 4.1.5.3 模块内部类的接口规范

##### PayController相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>PayController.makePaySheet</td>
		<td>语法</td>
		<td>Response makePaySheet(UserVO userVO, @RequestBody PaySheetVO paySheetVO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个PaySheetService对象，用户已登录且为财务人员用户，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统开启制定付款单流程，填写信息</td>
	</tr>
    	<tr>
		<td>PayController.showSheetByState</td>
		<td>语法</td>
		<td>Response showSheetByState(@RequestParam(value = "state", required = false) PaySheetState state)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个PaySheetService对象，用户已登录且为财务人员用户，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统展示给用户付款单列表</td>
	</tr>
    	<tr>
		<td>PayController.firstApproval</td>
		<td>语法</td>
		<td>Response firstApproval(@RequestParam("paySheetId") String paySheetId,
                                  @RequestParam("state") PaySheetState state)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个PaySheetService对象，用户已登录且为财务人员用户，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>单据通过第一级审批</td>
	</tr>
    	<tr>
		<td>PayController.secondApproval</td>
		<td>语法</td>
		<td>Response secondApproval(@RequestParam("paySheetId") String paySheetId,
                                   @RequestParam("state") PaySheetState state)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个PaySheetService对象，用户已登录且为财务人员用户，输入输出符合规则，单据通过第一级审批</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>单据通过第二级审批</td>
	</tr>

</table>


###### 需要的服务（需接口）

| 服务名                                                       | 服务           |
| ------------------------------------------------------------ | -------------- |
| PaySheetService.makePaySheet(UserVO userVO, PaySheetVO paySheetVO) | 制定付款单     |
| PaySheetService.getSheetByState(PaySheetState state)         | 获取付款单信息 |
| PaySheetService.approval(String paySheetId, PaySheetState  state) | 审批付款单     |

##### PaySheetService相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>PaySheetService.makePaySheet</td>
		<td>语法</td>
		<td>void makePaySheet(UserVO userVO, PaySheetVO paySheetVO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启制定付款单流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>数据库更新完毕，更新流程结束，向用户展示更新成功或失败的信息</td>
	</tr>
    <tr>
		<td>PaySheetService.approval</td>
		<td>语法</td>
		<td>void approval(String paySheetId, PaySheetState state)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>单据已生成</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>单据审批通过或被拒绝通过，数据库更新</td>
	</tr>
    <tr>
		<td>PaySheetService.getSheetByState</td>
		<td>语法</td>
		<td>List<PaySheetVO> getSheetByState(PaySheetState state)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>单据已生成</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统向用户展示单据信息</td>
	</tr>
</table>

###### 需要的服务（需接口）

| 服务名                                                       | 服务                           |
| ------------------------------------------------------------ | ------------------------------ |
| PaySheetDao.getLatestSheet()                                 | 在数据库中查询最近的付款单     |
| PaySheetDao.saveBatchSheetContent(List<PaySheetContentPO> pContentPOList) | 在数据库中插入单据信息         |
| PaySheetDao.saveSheet(PaySheetPO paySheetPO)                 | 在数据库中保存单据             |
| PaySheetDao.findSheetById(String  paySheetId)                | 在数据库中根据单据id查找单据   |
| PaySheetDao.updateSheetState(String  paySheetId,PaySheetState state) | 在数据库中更新单据状态         |
| PaySheetDao.updateSheetStateOnPrev(String paySheetId, PaySheetState PrevState,  PaySheetState state | 在数据库中更新单据状态         |
| PaySheetDao.findContentById(String PaySheetId)               | 在数据库中根据id查找单据内容   |
| AccountDao.findOneByName(String account)                     | 在数据库中根据账户名查找单据   |
| PaySheetDao.findAll()                                        | 在数据库中查找所有单据         |
| PaySheetDao.findAllbyState(PaySheetState state)              | 在数据库中根据单据状态查找单据 |

##### ReceiptController相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>ReceiptController.makeReceiptSheet</td>
		<td>语法</td>
		<td>Response makeReceiptSheet(UserVO userVO, @RequestBody ReceiptSheetVO receiptSheetVO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个ReceiptSheetService对象，用户已登录且为财务人员用户，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统开始制定收款单流程</td>
	</tr>
    <tr>
		<td>ReceiptController.showSheetByState</td>
		<td>语法</td>
		<td>Response showSheetByState(@RequestParam(value = "state", required = false) ReceiptSheetState state)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个ReceiptSheetService对象，用户已登录且为财务人员用户，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统开始展示给用户单据流程</td>
	</tr>
    <tr>
		<td>ReceiptController.firstApproval</td>
		<td>语法</td>
		<td>Response firstApproval(@RequestParam("receiptSheetId") String receiptSheetId,
                                  @RequestParam("state") ReceiptSheetState state)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个ReceiptSheetService对象，用户已登录且为财务人员用户，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>单据完成第一级审批</td>
	</tr>
    <tr>
		<td>ReceiptController.secondApproval</td>
		<td>语法</td>
		<td>Response secondApproval(@RequestParam("receiptSheetId") String receiptSheetId,
                                   @RequestParam("state") ReceiptSheetState state)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个ReceiptSheetService对象，用户已登录且为财务人员用户，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>单据完成第二级审批</td>
	</tr>
</table>


###### 需要的服务（需接口）

| 服务名                                                       | 服务                 |
| ------------------------------------------------------------ | -------------------- |
| ReceiptSheetService.makeReceiptSheet(UserVO userVO, ReceiptSheetVO receiptSheetVO) | 创建收款单           |
| ReceiptSheetService.getSheetByState(ReceiptSheetState state) | 根据单据状态获取单据 |
| ReceiptSheetService.approval(String receiptSheetId, ReceiptSheetState state)审批单据 | 审批单据             |

##### ReceiptSheetService相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>ReceiptSheetService.makeReceiptSheet</td>
		<td>语法</td>
		<td>void makeReceiptSheet(UserVO userVO, ReceiptSheetVO receiptSheetVO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启制定收款单流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>数据库更新完毕，更新流程结束，向用户展示更新成功或失败的信息</td>
	</tr>
    <tr>
		<td>ReceiptSheetService.approval</td>
		<td>语法</td>
		<td>void approval(String receiptSheetId, ReceiptSheetState state)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>单据已生成</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>单据被审批通过或拒绝不通过</td>
	</tr>
    <tr>
		<td>ReceiptSheetService.getSheetByState</td>
		<td>语法</td>
		<td>List<ReceiptSheetVO> getSheetByState(ReceiptSheetState state)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>单据已生成</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统根据单据状态获取单据，展示给用户</td>
	</tr>
</table>

###### 需要的服务（需接口）

| 服务名                                                       | 服务                                 |
| ------------------------------------------------------------ | ------------------------------------ |
| ReceiptSheetDao.getLatestSheet()                             | 在数据库中获取最近的收款单           |
| ReceiptSheetDao.saveBatchSheetContent(List<ReceiptSheetContentPO> receiptSheetContent) | 在数据库中插入单据内容               |
| ReceiptSheetDao.saveSheet(ReceiptSheetPO receiptSheetPO)     | 在数据库中存入单据                   |
| ReceiptSheetDao.findSheetById(String receiptSheetId)         | 在数据库中根据id查询收款单           |
| ReceiptSheetDao.updateSheetState(String receiptSheetId, ReceiptSheetState state) | 在数据库中更新单据状态               |
| ReceiptSheetDao.updateSheetStateOnPrev(String receiptSheetId, ReceiptSheetState PrevState, ReceiptSheetState state) | 在数据库中更新单据状态               |
| CustomerDao.findOneByName(String account)                    | 在数据库中根据客户姓名获取收款单     |
| ReceiptSheetDao.findAll()                                    | 在数据库中查找所有收款单             |
| ReceiptSheetDao.findAllByState(ReceiptSheetState state)      | 在数据库中根据单据状态查找所有收款单 |
| ReceiptSheetDao.findContentById(String receiptSheetId)       | 在数据库中根据单据id查找收款单内容   |

##### SalaryController相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>SalaryController.makeSalarySheet</td>
		<td>语法</td>
		<td>Response makeSalarySheet(@RequestParam String employeeId)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个SalaryService对象，用户已登录且为财务人员用户，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统开启创建工资单流程，将创建的工资单添加至审批列表中</td>
	</tr>
	<tr>
		<td>SalaryController.firstApproval</td>
		<td>语法</td>
		<td>Response firstApproval(@RequestParam("salarySheetId") String salarySheetId,
                                  @RequestParam("state") SalarySheetState state)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个SalaryService对象，用户已登录且为财务人员用户，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>单据完成第一级审批</td>
	</tr>
    	<tr>
		<td>SalaryController.secondApproval</td>
		<td>语法</td>
		<td>Response secondApproval(@RequestParam("salarySheetId") String salarySheetId,
                                   @RequestParam("state") SalarySheetState state)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个SalaryService对象，用户已登录且为财务人员用户，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>单据完成第二级审批</td>
	</tr>


###### 需要的服务（需接口）

| 服务名                                                       | 服务             |
| ------------------------------------------------------------ | ---------------- |
| SalaryService.makeSalarySheet(String employeeId)             | 创建工资单       |
| SalaryService.approval(String salarySheetId, SalarySheetState state) | 对工资单进行审批 |

##### SalaryService相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>SalaryService.calculate_tax</td>
		<td>语法</td>
		<td>BigDecimal calculate_tax(String tax, BigDecimal raw_salary)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启创建工资单流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>缴税计算完毕，自动填入工资单</td>
	</tr>
    	<tr>
		<td>SalaryService.makeSalarySheet</td>
		<td>语法</td>
		<td>void makeSalarySheet(String employeeId)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启创建工资单流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>数据库更新完毕，更新流程结束，向用户展示更新成功或失败的信息</td>
	</tr>
    	<tr>
		<td>SalaryService.approval</td>
		<td>语法</td>
		<td>void approval(String salarySheetId, SalarySheetState state)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>单据已生成</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>单据被审批通过或拒绝不通过</td>
	</tr>
</table>


###### 需要的服务（需接口）

| 服务名                                                       | 服务                       |
| ------------------------------------------------------------ | -------------------------- |
| EmployeeDao.getOneById(String employeeId)                    | 在数据库中根据id查找员工   |
| SalaryDao.save(SalarySheetPO salarySheetPO)                  | 在数据库中插入工资单       |
| SalaryDao.findSheetById(String salarySheetId)                | 在数据库中根据id查找工资单 |
| SalaryDao.updateSheetState(String salarySheetId, SalarySheetState state) | 在数据库中更新工资单状态   |
| SalaryDao.updateSheetStateOnPrev(String salarySheetId, SalarySheetState PrevState, SalarySheetState state) | 在数据库中更新工资单状态   |

##### YearEndBonusController相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>YearEndBonusController.giveBonus</td>
		<td>语法</td>
		<td>Response giveBonus(SalarySheetVO salarySheetVO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个YearEndBonusService对象，用户已登录且为总经理用户，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统在工资单基础上开启制定年终奖流程，填写信息</td>
	</tr>



</table>


###### 需要的服务（需接口）

| 服务名                                                     | 服务       |
| ---------------------------------------------------------- | ---------- |
| YearEndBonusService.giveBonus(SalarySheetVO salarySheetVO) | 填写年终奖 |

##### YearEndBonusService相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>YearEndBonusService.giveBonus</td>
		<td>语法</td>
		<td>void giveBonus(SalarySheetVO salarySheetVO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启制定工资单流程，用户为总经理</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>工资单中填入年终奖完毕，数据库更新完毕，更新流程结束，向用户展示更新成功或失败的信息</td>
	</tr>
</table>


###### 需要的服务（需接口）

| 服务名                                      | 服务                     |
| ------------------------------------------- | ------------------------ |
| salaryDao.save(SalarySheetPO salarySheetPO) | 在数据库中存放工资单     |
| employeeDao.getOneById(Integer id)          | 在数据库中根据id查找员工 |

##### 4.1.5.4 动态模型

![制定单据顺序图.png](https://s2.loli.net/2022/07/07/Xl3agi7KocPdyG1.png)

#### 4.1.6 期初建账模块

##### 4.1.6.1模块概述

期初建账模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

期初建账模块的职责及接口参见软件系统结构描述文档表。

##### 4.1.6.2整体结构

根据整体结构的设计，我们将系统分为展示层，业务逻辑层，数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加InitialAccountService接口。业务逻辑层和数据层之间添加initialAccountDao接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了InitialAccountController，这样Controller会把业务逻辑处理委托给ServiceImpl对象。PO是作为持久化对象被添加到设计模型中去的，作为数据层和业务逻辑层之间传递的数据对象，VO对象是业务逻辑层和控制层之间传递的数据对象。Service和Dao的接口都是根据依赖倒置原则，避免循环依赖而产生的接口。

期初建账模块的设计图如下图所示。

![财务人员：初期建账.png](https://s2.loli.net/2022/07/09/bGmryR6cSELIken.png)

期初建账模块各个类的职责如下表所示。

| 模块                     | 职责                                                         |
| ------------------------ | ------------------------------------------------------------ |
| InitialAccountController | 负责处理用户发来的期初建账相关的请求并调用InitialAccountService中对应的业务逻辑 |
| InitialAccountService    | 负责实现期初建账相关的业务逻辑                               |
| InitialAccountDao        | 期初建账的接口。提供期初建账的增、删、改、查的服务。         |

##### 4.1.6.3 模块内部类的接口规范

##### InitialAccountController相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>InitialAccountController.initialAccount</td>
		<td>语法</td>
		<td>Response InitialAccount(@RequestBody InitialAccountVO initialAccountVO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个InitialAccountService对象，用户已登录且为财务人员用户，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统开启期初建账流程</td>
	</tr>
</table>




###### 需要的服务（需接口）

| 服务名                                                       | 服务     |
| ------------------------------------------------------------ | -------- |
| InitialAccountService.initialAccount(InitialAccountVO initialAccountVO) | 期初建账 |

##### InitialAccountService相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>InitialAccountService.initialAccount</td>
		<td>语法</td>
		<td>void initialAccount(InitialAccountVO initialAccountVO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>用户选择期初建账，系统开启期初建账流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>数据库更新完毕，更新流程结束，向用户展示更新成功或失败的信息</td>
	</tr>
</table>



###### 需要的服务（需接口）

| 服务名                                                       | 服务                               |
| ------------------------------------------------------------ | ---------------------------------- |
| saleSheetDao.findContentByTime(String name,Date firstTime,Date latestTime) | 在数据库中获取对应时间段的销售明细 |
| purchaseSheetDao.findContentByTime(String name,Date firstTime,Date latestTime) | 在数据库中获取对应时间段的进货单   |
| productDao.findById(String id）                              | 在数据库中根据商品id查找商品       |
| customerService.findCustomerById(Interger id)                | 在数据库中根据客户id查找客户       |
| initialAccountDao.save(InitialAccountPO initialAccountPO)    | 在数据库中插入系统最初信息         |
| productDao.createProduct(ProductPO productPO)                | 在数据库中插入新的商品信息         |
| customerDao.createCustomer(CustomerPO customerPO)            | 在数据库中插入新的客户信息         |
| accountDao.addAccount(AccountPO accountPO)                   | 在数据库中插入新的账户信息         |

##### 4.1.6.4 动态模型

![期初建账顺序图.png](https://s2.loli.net/2022/07/09/83LOCQPhxHqDt6y.png)

#### 4.1.7员工管理模块

##### 4.1.7.1模块概述

 员工管理模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

 员工管理模块的职责及接口参见软件系统结构描述文档中的表。

##### 4.1.7.2整体结构

根据整体结构的设计，我们将系统分为展示层，业务逻辑层，数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加EmployeeService接口。业务逻辑层和数据层之间添加EmployeeDao接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了EmployeeController，这样Controller会把业务逻辑处理委托给ServiceImpl对象。PO是作为帖子和评论的持久化对象被添加到设计模型中去的。Service和Dao的接口都是根据依赖倒置原则，避免循环依赖而产生的接口。

员工管理模块的设计图如下图所示。

![人力资源：员工管理（薪酬规则制定）.png](https://s2.loli.net/2022/07/08/n4MKCaOIGREeHtU.png)

员工管理模块各个类的职责如下表所示。

| 模块               | 职责                                                         |
| ------------------ | ------------------------------------------------------------ |
| EmployeeController | 负责处理用户发来的员工管理相关的请求并调用EmployeeService中对应的业务逻辑 |
| EmployeeService    | 负责实现员工管理相关的业务逻辑                               |
| EmployeeDao        | 员工管理的接口。提供员工管理的增删改查服务。                 |

##### 4.1.7.3 模块内部类的接口规范

##### EmployeeController相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>EmployeeController.createEmployee</td>
		<td>语法</td>
		<td>Response createEmployee(@RequestBody EmployeeVO employeeVO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个EmployeeService对象，用户已登录，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统开启新增员工流程</td>
	</tr>
    	<tr>
		<td>EmployeeController.updateEmployee</td>
		<td>语法</td>
		<td>Response updateEmployee(@RequestBody EmployeeVO employeeVO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个EmployeeService对象，用户已登录，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统开启编辑员工信息流程</td>
	</tr>	<tr>
		<td>EmployeeController.query</td>
		<td>语法</td>
		<td>Response queryAll()</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个EmployeeService对象，用户已登录，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统查找员工并返回给用户</td>
	</tr>
</table>




###### 需要的服务（需接口）

| 服务名                                                | 服务                         |
| ----------------------------------------------------- | ---------------------------- |
| EmployeeService.createEmployee(EmployeeVO employeeVO) | 创建新的员工信息             |
| EmployeeService.updateEmployee(EmployeeVO employeeVO) | 编辑员工信息                 |
| EmployeeService.queryAll()                            | 查询所有员工信息并返回给用户 |

##### EmployeeService相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>EmployeeService.createEmployee</td>
		<td>语法</td>
		<td>void createEmployee(EmployeeVO employeeVO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启新建员工信息流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>数据库更新完毕，更新流程结束，向用户展示更新成功或失败的信息</td>
	</tr>
    	<tr>
		<td>EmployeeService.updateEmployee</td>
		<td>语法</td>
		<td>void updateEmployee(EmployeeVO employeeVO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启编辑员工信息流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>数据库更新完毕，更新流程结束，向用户展示更新成功或失败的信息</td>
	</tr>
        	<tr>
		<td>EmployeeService.queryAll</td>
		<td>语法</td>
		<td>List<EmployeeVO> queryAll()</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>用户跳转至员工管理界面</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统展示给用户员工信息</td>
	</tr>

</table>

###### 需要的服务（需接口）

| 服务名                                    | 服务                         |
| ----------------------------------------- | ---------------------------- |
| EmployeeDao.add(EmployeePO employeePO)    | 在数据库中插入新增员工       |
| UserService.register(UserVO userVO)       | 在数据库中为新增员工注册账号 |
| EmployeeDao.update(EmployeePO employeePO) | 在数据库中更新员工信息       |
| EmployeeDao.queryAll()                    | 在数据库中查询所有员工信息   |

##### 4.1.7.4动态模型

![员工管理顺序图.png](https://s2.loli.net/2022/07/07/IsoJqaS6DHkiebC.png)



##### 4.1.7.5业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同领域对象。

#### 4.1.8 员工打卡模块

##### 4.1.8.1模块概述

 员工打卡模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

 员工打卡模块的职责及接口参见软件系统结构描述文档中的表。

##### 4.1.8.2整体结构

根据整体结构的设计，我们将系统分为展示层，业务逻辑层，数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加ClockInService接口。业务逻辑层和数据层之间添加ClockInDao接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了ClockInController，这样Controller会把业务逻辑处理委托给ServiceImpl对象。PO是作为帖子和评论的持久化对象被添加到设计模型中去的。Service和Dao的接口都是根据依赖倒置原则，避免循环依赖而产生的接口。

员工打卡模块的设计图如下图所示。

![人力资源：员工打卡.png](https://s2.loli.net/2022/07/08/Pm5OpqFVvsowiQY.png)

员工打卡模块各个类的职责如下表所示。

| 模块              | 职责                                                         |
| ----------------- | ------------------------------------------------------------ |
| ClockInController | 负责处理用户发来的员工打卡相关的请求并调用ClockInService中对应的业务逻辑 |
| ClockInService    | 负责实现员工打卡相关的业务逻辑                               |
| ClockInDao        | 员工打卡的接口。提供员工打卡的输入信息、更新、查询服务       |

##### 4.1.8.3 模块内部类的接口规范

##### ClockInController相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>ClockInController.createClockIn</td>
		<td>语法</td>
		<td>Response createClockIn(@RequestParam ClockInPO clockInPo)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个ClockInService对象，用户已登录，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统提示用户打卡成功并为用户打卡天数+1</td>
	</tr>	<tr>
		<td>ClockInController.findByTelenum</td>
		<td>语法</td>
		<td>Response findByTelenum(@RequestParam String telephone , @RequestParam String name)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>已创建一个ClockInService对象，用户已登录，输入输出符合规则</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统返回用户打卡情况</td>
	</tr>
</table>




###### 需要的服务（需接口）

| 服务名                                            | 服务                           |
| ------------------------------------------------- | ------------------------------ |
| ClockInService.createClockIn(ClockInPO clockInPO) | 员工点击进行打卡               |
| ClockInService.findByTelenum(String telephone)    | 更新员工打卡信息               |
| ClockInService.updateClockIn(ClockInPO clockInPO) | 根据手机号返回员工今日打卡情况 |

##### ClockInService相关规范

###### 提供的服务（供接口）

<table>
	<tr>
		<td>ClockInService.createClockIn</td>
		<td>语法</td>
		<td>void createClockIn(ClockInPO clockInPO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启员工打卡流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统提示用户打卡成功并为用户打卡天数+1</td>
	</tr>
    	<tr>
		<td>ClockInService.updateClockIn</td>
		<td>语法</td>
		<td>void updateClockIn(ClockInPO clockInPO)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启更新打卡信息流程</td>
	</tr>
	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统展示给用户打卡信息</td>
	</tr>
        	<tr>
		<td>ClockInService.findByTelenum</td>
		<td>语法</td>
		<td>List<ClockInPO> findByTelenum(String telenum)</td>
	</tr>
	<tr>
		<td></td>
		<td>前置条件</td>
		<td>系统开启查询打卡情况流程</td>
	</tr>
    	<tr>
		<td></td>
		<td>后置条件</td>
		<td>系统展示给用户电话号码对应用户的今日打卡情况</td>
	</tr>

</table>

###### 需要的服务（需接口）

| 服务名                                        | 服务                                       |
| --------------------------------------------- | ------------------------------------------ |
| ClockInDao.createClockIn(ClockInPO clockInPO) | 在数据库中为对应员工打卡天数+1             |
| ClockInDao.updateClockIn(ClockInPO clockInPO) | 在数据库中更新员工打卡信息                 |
| ClockInDao.findByTelenum(String telenum)      | 在数据库中查询对应手机号对应用户的打卡情况 |

##### 4.1.6.4动态模型

![员工打卡顺序图.png](https://s2.loli.net/2022/07/07/KIB1FOQMNTf2m4i.png)



##### 4.1.6.5业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同领域对象。

## 5.依赖视角

ERP进销存管理系统的客户端开发包图如下图所示。

![开发包图 _1_.png](https://s2.loli.net/2022/07/08/gxCpAVmuHzhesTE.png)

ERP进销存管理系统的服务器端开发包图如下图所示。

![服务器端包图 _1_.png](https://s2.loli.net/2022/07/09/GIEbVvyklnemUST.png)